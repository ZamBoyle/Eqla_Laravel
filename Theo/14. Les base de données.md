# Les bases de données
## 1. Introduction
Nous allons parler des bases de données dans Laravel. Laravel propose une solution élégante/simple que nous allons voir en partie. Comme d'habitude, n'hésitez pas à consulter le site Laravel pour la documentation officielle: [Database: Getting Started](https://laravel.com/docs/8.x/database)

Pour vos tests, vous pourriez utiliser [Laravel Sail](https://laravel.com/docs/8.x/sail) qui permet d'avoir simplement un environnement dockerisé (utilisation d'un conteneur docker). Il contient: PHP et Mysql. Ceci ne rentre pas dans le cadre du cours mais sachez que c'est possible et vraiment très bien fait. Mais nous continuerons d'utiliser localement php, artisan et votre base de données Mysql.

## 2. Bases de données
Nous allons utiliser MySql car il est installé chez la plupart des personnes mais utiliser une autre base de données reviendrait au même: PosgreSQL, SQLite, Mariadb, etc.

Informations sur les différentes DB:
- MySQL 5.7+
- [SQLite 3.8.8+](https://laravel.com/docs/8.x/database#sqlite-configuration)
- PosgreSQL 9.6+
- [Microsoft SQL Server 2017+](https://laravel.com/docs/8.x/database#mssql-configuration): les extensions PHP seront nécessaires sqlsrv et pdo_sqlsrv. Le driver ODBC de Microsoft SQL peut aussi être nécessaire. 

Dans Laravel on va utiliser le fichier .env pour indiquer nos credetials (login/password), le type de base de données, la base de données, l'ip/host et le port.

### 2.1 Mysql
Il faut que Mysql soit évidemment installé et que vous ayez toutes les informations de connexion.

Exemple d'entrées dans le fichier .env:
```php
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=cupcake
DB_USERNAME=root
DB_PASSWORD=votreMotDePasse
```
Adaptez votre fichier .env avec votre configuration de Mysql.

Si la base de données cupcake n'existe pas, créez-la:
```console
mysql -u root -p
-- On va afficher les bases de données et on vérifie que cupcake n'existe pas
show databases;
-- Si cupcake n'existe pas.
create database cupcake;
-- on sort du client mysql
exit;
```

### 2.2 SQLite
Pour SQLite il faut simplement créer un fichier vide ou utiliser un fichier existant.
Pour les exemples, nous allons mettre ce fichier dans le répertoire database de Laravel et de le nommer par exemple: database.sqlite

Ensuite on met ces entrées dans le fichier .env
```php
DB_CONNECTION=sqlite
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=d:\monProjetLaravel\database\database.sqlite
```

## 3. Fichier .env
Le fichier .env est utilisé par Laravel pour déterminer un exemple de choses très importantes comme par exemples:
- APP_NAME: Le nom de l'application
- APP_ENV: L'environnement de l'application
- APP_KEY: La clef de l'application
- APP_DEBUG: L'application est-elle en mode debug ? Si on met à false on n'aura plus un dump détaillé quand une erreur survient. Ce qui est obligatoire avec un site en production !
- etc...

### 3.1 Accès aux variables
Toutes les variables contenues dans ce fichier seront chargées dans la variable PHP super globale $_ENV.

On peut y accéder via par exemple $\_ENV['APP_NAME'] ou bien env('APP_NAME');

### 3.2 Protection

Il faut donc bien faire attention avec ce fichier car une partie des infos de notre application sont exposées. par exemple: http://monsiteLaravel/.env et vous pourriez avoir toute la config affichée dans un navigateur: mot de passe, addresse de la base de données, etc.

Pour éviter cela, on peut créer/modifier un fichier .htaccess.

Fichier .htaccess:
```
#Disable index view //On empêche de voir le contenu des répertoires
options -Indexes

#hide a Specifuc File // On cache le fichier .env
<Files .env>
order allow,deny
Deny from all
</Files>
```

De plus, si vous voulez utiliser git et que vous n'avez pas créé votre projet via la commande laravel:
```console
laravel new monProjet --git
```

Vous devez ajouter avant votre premier commit le fichier .gitignore, ajoutez ce contenu généré par l'option --git
```console
/node_modules
/public/hot
/public/storage
/storage/*.key
/vendor
.env
.env.backup
.phpunit.result.cache
docker-compose.override.yml
Homestead.json
Homestead.yaml
npm-debug.log
yarn-error.log
/.idea
/.vscode
```

Vous constatez que le fichier .env fait partie du fichier .gitignore. Lorsque vous pousserez vos modifications, .env ne sera pas envoyé et sera gardé précieusement. ;)

Le plus simple est tout de même de créer votre projet avec l'option --git si vous utilisez la commande laravel.

## 4. Les migrations
Les migrations permettent de créer/modifier une base de données: tables, index, relation, etc. Toute modification est enregistrée. Il y a donc un suivi de tout ce que vous avez fait sur vos tables. On peut même faire marche arrière sur une migration (rollback). C'est un peu le git de votre base de données.

Dans tout nouveau projet Laravel, il y a des migrations qui n'ont pas été exécutées.
Celles-ci se trouvent dans le répertoire database\migrations: 
- 2014_10_12_000000_create_users_table.php
- 2014_10_12_100000_create_password_resets_table.php
- 2019_08_19_000000_create_failed_jobs_table.php
- 2019_12_14_000001_create_personal_access_tokens_table.php

Nous allons les exécuter ces migrations qui permettront à Laravel de faire la gestion des utilisateurs.
```console
php artisan migrate
```
Résultat de la commande:
```console
Migration table created successfully.
Migrating: 2014_10_12_000000_create_users_table
Migrated:  2014_10_12_000000_create_users_table (46.03ms)
Migrating: 2014_10_12_100000_create_password_resets_table
Migrated:  2014_10_12_100000_create_password_resets_table (45.00ms)
Migrating: 2019_08_19_000000_create_failed_jobs_table
Migrated:  2019_08_19_000000_create_failed_jobs_table (40.15ms)
Migrating: 2019_12_14_000001_create_personal_access_tokens_table
Migrated:  2019_12_14_000001_create_personal_access_tokens_table (112.35ms)
```

Regardons les tables qui ont été créées:
```console
mysql -u root -p
use cupcake;
show tables;
```
Résultat:
```console
+------------------------+
| Tables_in_cupcake      |
+------------------------+
| failed_jobs            |
| migrations             |
| password_resets        |
| personal_access_tokens |
| users                  |
+------------------------+
5 rows in set (0.00 sec)
```
Ces tables sont toutes vides sauf la table migrations. Regardons le contenu de celle-ci:
```console
mysql -u root -p
use cupcake;
select * from migrations;
```
Résultat:
```console
+----+-------------------------------------------------------+-------+
| id | migration                                             | batch |
+----+-------------------------------------------------------+-------+
|  1 | 2014_10_12_000000_create_users_table                  |     1 |
|  2 | 2014_10_12_100000_create_password_resets_table        |     1 |
|  3 | 2019_08_19_000000_create_failed_jobs_table            |     1 |
|  4 | 2019_12_14_000001_create_personal_access_tokens_table |     1 |
+----+-------------------------------------------------------+-------+
4 rows in set (0.00 sec)
```
On voit que ces enregistrements correspondent aux noms des fichiers contenus dans le répertoire database\migrations. 

### 4.1 Comparons table et migration
Prenons la table users et regardons la structure des champs:
```console
mysql -u root -p
use cupcake;
show fields from users;
exit;
```
Résultat:
```
+-------------------+-----------------+------+-----+---------+----------------+
| Field             | Type            | Null | Key | Default | Extra          |
+-------------------+-----------------+------+-----+---------+----------------+
| id                | bigint unsigned | NO   | PRI | NULL    | auto_increment |
| name              | varchar(255)    | NO   |     | NULL    |                |
| email             | varchar(255)    | NO   | UNI | NULL    |                |
| email_verified_at | timestamp       | YES  |     | NULL    |                |
| password          | varchar(255)    | NO   |     | NULL    |                |
| remember_token    | varchar(100)    | YES  |     | NULL    |                |
| created_at        | timestamp       | YES  |     | NULL    |                |
| updated_at        | timestamp       | YES  |     | NULL    |                |
+-------------------+-----------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)
```
Maintenant, regardons le fichier correspondant, c'est à dire 2014_10_12_000000_create_users_table.php
```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateUsersTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('users');
    }
}
```
Je vous laisse 5 minutes pour l'analyser et me dire ce que vous avez constaté.
- Que fait la fonction up() ?
- Que fait la fonction down() ?

## 4.1 Options de migration
Voici les options de migration:
- php artisan migrate   => Exécute toutes les migrations du répertoire database\migrations
- php artisan migrate:rollback => Revient à l'état précédent l'actuelle migration.
- php artisan migrate:refresh => Fait un rollback de toutes les migrations via la méthode down() de chaque migration. Ensuite relance les migrations. ATTENTION A NE JAMAIS EXECUTER EN PRODUCTION !!!!
- php artisan migrate:fresh => Supprime toutes les tables et relance toutes les migrations. ATTENTION A NE JAMAIS EXECUTER EN PRODUCTION !!!!
- php artisan migrate:status => indique le status des migrations: exécutées ou non.

## 5. Eloquent
Eloquent est l'ORM utilisé par Laravel:
> Un mapping objet-relationnel (en anglais object-relational mapping ou ORM) est un type de programme informatique qui se place en interface entre un programme applicatif et une base de données relationnelle pour simuler une base de données orientée objet. 
> 
> Ce programme définit des correspondances entre les schémas de la base de données et les classes du programme applicatif. On pourrait le désigner par là, « comme une couche d'abstraction entre le monde objet et monde relationnel ».
> 
> Du fait de sa fonction, on retrouve ce type de programme dans un grand nombre de frameworks sous la forme de composant ORM qui a été soit développé, soit intégré depuis une solution externe.

Source [Wikipedia](https://fr.wikipedia.org/wiki/Mapping_objet-relationnel).

### 5.1 Eloquent et le design pattern 'Active record'
Dans le design pattern [Active record](https://fr.wikipedia.org/wiki/Active_record) est utilisé pour faire correspondre une table à une classe. Les attributs de la table sont encapsulés dans une classe. De cette manière, un enregistrement d'une table correspond à un objet.

### 5.2 Création d'un user via tinker
Tinker est très utile quand vous voulez interagir avec votre base de données très rapidement sans faire de programme. Et il est parfait pour vous présenter Eloquent et le design patter Active record.

Nous allons créer un premier user dans notre base de données avec tinker:
```console
php artisan tinker
//Nouvelle instance de User
$user = new App\Models\User;
//On remplit les attributs name, emai, password
$user->name='Piette';
$user->email='johnny.piette@gmail.com';
$user->password=bcrypt('!password');
//On sauve notre objet dans la base de données :)
$user->save();
//Affichons le contenu de notre objet après save()
$user;
```
Résultat de $user dans tinker:
```console
=> App\Models\User {#3510
     name: "Piette",
     email: "johnny.piette@gmail.com",
     #password: "$2y$10$Yl/YfrtiykRVbnghPhuj8.iKB/s16gPJNnpya0g6niIPQ769QaFam",
     updated_at: "2021-10-26 01:30:03",
     created_at: "2021-10-26 01:30:03",
     id: 1,
   }
```
Ne fermez pas votre console tinker, nous allons avoir besoin plus loin de $user.

Vérifions que l'utilisateur a bien été créé et qu'il correspond à $user:
```console
mysql -u root -p
use cupcake;
select * from users;
exit;
```
Résultat:
```console
+----+--------+-------------------------+-------------------+--------------------------------------------------------------+----------------+---------------------+---------------------+
| id | name   | email                   | email_verified_at | password                                                     | remember_token | created_at          | updated_at          |
+----+--------+-------------------------+-------------------+--------------------------------------------------------------+----------------+---------------------+---------------------+
|  1 | Piette | johnny.piette@gmail.com | NULL              | $2y$10$Yl/YfrtiykRVbnghPhuj8.iKB/s16gPJNnpya0g6niIPQ769QaFam | NULL           | 2021-10-26 01:30:03 | 2021-10-26 01:30:03 |
+----+--------+-------------------------+-------------------+--------------------------------------------------------------+----------------+---------------------+---------------------+
```
Et oui, ça correspond ! :)

Notez au passage que l'on a utilisé bcrypt qui a crypté notre mot de passe car dans une DB, il ne faut jamais stocker un mot de passe en clair: just a reminder. ;) 

### 5.3 Mise à jour de User via tinker
Nous allons changer le nom de l'objet $user:
```console
-- On change la valeur de l'attribut 'name'
$user->name='Defalque';
$user->save();
$user;
```
Résultat:
```console
=> App\Models\User {#3510
     name: "Piette Jacques",
     email: "johnny.piette@gmail.com",
     #password: "$2y$10$Yl/YfrtiykRVbnghPhuj8.iKB/s16gPJNnpya0g6niIPQ769QaFam",
     updated_at: "2021-10-26 01:42:20",
     created_at: "2021-10-26 01:30:03",
     id: 1,
   }
```

### 5.4 Recherche de Users via tinker
Nous allons avant créer un nouveau User:
```console
//Nouvelle instance de User
$user = new App\Models\User;
//On remplit les attributs name, emai, password
$user->name='Piettus';
$user->email='djoni.piettus@gmail.com';
$user->password=bcrypt('!password');
//On sauve notre objet dans la base de données :)
$user->save();
```

#### 5.4.1 find, all méthodes
On va rechercher l'utilisateur avec l'id = 1 et ensuite id=2. Enfin, on affichera tous les utilisateurs.

- Utlisateur avec l'id = 1 et ensuite l'id = 2
    ```console
    App\Models\User::find(1);
    App\Models\User::find(2);
    ```
- Afficher tous les Users
    ```console
    App\Models\User::all();
    ```
    Résultat de tous les Users:
    ```console
    => Illuminate\Database\Eloquent\Collection {#4446
        all: [
        App\Models\User {#4445
            id: 1,
            name: "Piette Jacques",
            email: "johnny.piette@gmail.com",
            email_verified_at: null,
            #password: "$2y$10$Yl/YfrtiykRVbnghPhuj8.iKB/s16gPJNnpya0g6niIPQ769QaFam",
            #remember_token: null,
            created_at: "2021-10-26 01:30:03",
            updated_at: "2021-10-26 01:42:20",
        },
        App\Models\User {#4444
            id: 2,
            name: "Piettus",
            email: "djoni.piettus@gmail.com",
            email_verified_at: null,
            #password: "$2y$10$oLp1C499P8IAlDlXjANiBe5X2H/qIDB7RKd3aj2/i47IWlegWV08W",
            #remember_token: null,
            created_at: "2021-10-26 02:03:00",
            updated_at: "2021-10-26 02:03:00",
        },
        ],
    }
    ```
J'ai affiché le résultat de tous les Users car il est intéressant de remarquer qu'Eloquent nous indique que ce qui est retourné est une Collection: un tableau.

C'est beau non ? :)

### 5.5 pluck méthode

Maintenant, j'ai envie de connaître tous les noms d'utilisateurs et rien d'autre.
```console
User::pluck('name');
```
Résultat:
```console
=> Illuminate\Support\Collection {#4391
     all: [
       "Piette Jacques",
       "Piettus",
     ],
   }
```
A nouveau une collection où l'on voit tous les noms.
Pour afficher le premier résultat de pluck, je peux le faire de deux manières:
```console
    -- Première manière
    App\Models\User::pluck('name')[0];
    -- Seconde manière
    App\Models\User::pluck('name')->firs();
```

## 6. Création de la table Cupcake
```console
php artisan make:migration create_cupcakes_table
```
Le fichier de migration a été créé dans le répertoire database\migrations
Ouvrez ce fichier et modifiez-le de la sorte:
```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateCupcakesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('cupcakes', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('description');
            $table->string('imageName');
            $table->integer('stock');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('cupcakes');
    }
}
```
Laravel a compris grâce au verbe create qu'il doit créer une table cupcakes et a ajouté tout seul le nom de la table. De base, il ajoute un id et un timestamps.
Lançons notre migration:
```console
php artisan migrate
```
La table cupcakes a été créée avec les champs correspondants à ceux que nous avons définis.

## 7. Création du modèle Cupcake
Nous avons créé notre table cupcakes. Maintenant, nous allons créer la classe Cupcake qui permettra d'appliquer le design pattern Active record.
```console
php artisan make:model Cupcake
```
La classe Cupcake a été créée dans le répertoire App\Models

## 8. Ajout d'un cupcake via Tinker
```console
php artisan tinker
$cupcake = new App\Models\Cupcake;
$cupcake->name = 'Le Pinky';
$cupcake->description = 'Bla bla bla bla...';
$cupcake->imageName = 'cupcake1.jpg'; 
$cupcake->stock = 10;
$cupcake->save();
```
Et voilà ! Notre object $cupcake est devenu persistant dans le base de données. D'un objet, il est devenu un enregistrement dans la table cupcakes.