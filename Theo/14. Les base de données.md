# Les bases de données

- [Les bases de données](#les-bases-de-données)
  - [1. Introduction](#1-introduction)
  - [2. Bases de données](#2-bases-de-données)
    - [2.1 Mysql](#21-mysql)
    - [2.2 SQLite](#22-sqlite)
  - [3. Fichier .env](#3-fichier-env)
    - [3.1 Accès aux variables](#31-accès-aux-variables)
    - [3.2 Protection](#32-protection)
  - [4. Les migrations](#4-les-migrations)
    - [4.1 Comparons table et migration](#41-comparons-table-et-migration)
    - [4.2 Options de migration](#42-options-de-migration)
    - [4.3 Valeur par défaut](#43-valeur-par-défaut)
  - [5. Eloquent](#5-eloquent)
    - [5.1 Eloquent et le design pattern 'Active record'](#51-eloquent-et-le-design-pattern-active-record)
    - [5.3 Tinker](#53-tinker)
    - [5.3 Création d'un user via tinker](#53-création-dun-user-via-tinker)
    - [5.4 Mise à jour de User via tinker](#54-mise-à-jour-de-user-via-tinker)
    - [5.5 méthodes find, all](#55-méthodes-find-all)
    - [5.6 pluck méthode](#56-pluck-méthode)
    - [5.7 Mettre à jour un enregistrement](#57-mettre-à-jour-un-enregistrement)
      - [5.7.1 via la méthode save()](#571-via-la-méthode-save)
      - [5.7.2 via la méthode update()](#572-via-la-méthode-update)
    - [5.8 Les conditions](#58-les-conditions)
      - [5.8.1 Opérateurs de comparaison](#581-opérateurs-de-comparaison)
  - [6. Création de la table Cupcake](#6-création-de-la-table-cupcake)
  - [7. Création du modèle Cupcake](#7-création-du-modèle-cupcake)
  - [8. Ajout d'un cupcake via Tinker](#8-ajout-dun-cupcake-via-tinker)
  - [9. Stocker un Mot de passe en DB](#9-stocker-un-mot-de-passe-en-db)
  - [10. Vérifier un Mot de passe](#10-vérifier-un-mot-de-passe)
  - [11. Ajouter une colonne](#11-ajouter-une-colonne)
  - [12. Mettre à jour une colonne](#12-mettre-à-jour-une-colonne)
  - [13. Supprimer une colonne](#13-supprimer-une-colonne)
  - [14. Les relations](#14-les-relations)
    - [14.1 One to many](#141-one-to-many)

## 1. Introduction
Nous allons parler des bases de données dans Laravel. Laravel propose une solution élégante/simple que nous allons voir en partie. Comme d'habitude, n'hésitez pas à consulter le site Laravel pour la documentation officielle: [Database: Getting Started](https://laravel.com/docs/11.x/database)

Pour vos tests, vous pourriez utiliser [Laravel Sail](https://laravel.com/docs/11.x/sail) qui permet d'avoir simplement un environnement dockerisé (utilisation d'un conteneur docker). Il contient: PHP et Mysql. Ceci ne rentre pas dans le cadre du cours mais sachez que c'est possible et vraiment très bien fait. Mais nous continuerons d'utiliser localement php, artisan et votre base de données Mysql.

## 2. Bases de données
Nous allons utiliser MySql car il est installé chez la plupart des personnes mais utiliser une autre base de données reviendrait au même: PosgreSQL, SQLite, Mariadb, etc.

Informations sur les différentes DB:
- MySQL 5.7+
- [SQLite 3.8.8+](https://laravel.com/docs/11.x/database#sqlite-configuration)
- PosgreSQL 9.6+
- [Microsoft SQL Server 2017+](https://laravel.com/docs/11.x/database#mssql-configuration): les extensions PHP seront nécessaires sqlsrv et pdo_sqlsrv. Le driver ODBC de Microsoft SQL peut aussi être nécessaire. 

Dans Laravel on va utiliser le fichier .env pour indiquer nos credetials (login/password), le type de base de données, la base de données, l'ip/host et le port.

### 2.1 Mysql
Il faut que Mysql soit évidemment installé et que vous ayez toutes les informations de connexion.

Exemple d'entrées dans le fichier .env:
```php
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=cupcake
DB_USERNAME=root
DB_PASSWORD=votreMotDePasse
```

Adaptez votre fichier .env avec votre configuration de Mysql.

Si la base de données cupcake n'existe pas, créez-la:
```console
mysql -u root -p
-- On va afficher les bases de données et on vérifie que cupcake n'existe pas
show databases;
-- Si cupcake n'existe pas.
create database cupcake;
-- on sort du client mysql
exit;
```

Il faut activer mysql_pdo dans le php.ini en décommentant (enlever le ; du début de ligne) la ligne
extension=pdo_mysql

### 2.2 SQLite
Pour SQLite il faut simplement créer un fichier vide ou utiliser un fichier existant.
Pour les exemples, nous allons mettre ce fichier dans le répertoire database de Laravel et de le nommer par exemple: database.sqlite

Ensuite on met ces entrées dans le fichier .env
```php
DB_CONNECTION=sqlite
DB_DATABASE=d:\monProjetLaravel\database\database.sqlite
```

Il faut activer pdo_sql dans le php.ini en décommentant (enlever le ; du début de ligne) la ligne
extension=pdo_sqlite


## 3. Fichier .env
Le fichier .env est utilisé par Laravel pour déterminer un exemple de choses très importantes comme par exemples:
- APP_NAME: Le nom de l'application
- APP_ENV: L'environnement de l'application
- APP_KEY: La clef de l'application
- APP_DEBUG: L'application est-elle en mode debug ? Si on met à false on n'aura plus un dump détaillé quand une erreur survient. Ce qui est obligatoire avec un site en production !
- etc...

### 3.1 Accès aux variables
Toutes les variables contenues dans ce fichier seront chargées dans la variable PHP super globale $_ENV.

On peut y accéder via par exemple $\_ENV['APP_NAME'] ou bien env('APP_NAME');

### 3.2 Protection
<!--
Il faut donc bien faire attention avec ce fichier car une partie des infos de notre application sont exposées. par exemple: http://monsiteLaravel/.env et vous pourriez avoir toute la config affichée dans un navigateur: mot de passe, addresse de la base de données, etc.

Pour éviter cela, on peut créer/modifier un fichier .htaccess.

Fichier .htaccess:
```
#Disable index view //On empêche de voir le contenu des répertoires
options -Indexes

#hide a Specifuc File // On cache le fichier .env
<Files .env>
order allow,deny
Deny from all
</Files>
```
-->
Si vous créez votre projet avec la commande laravel avec l'option --git, le fichier .env sera ignoré par git ainsi que d'autres fichiers sensibles comme la base de données sqlite.

Si vous voulez utiliser git et que vous n'avez pas créé votre projet via la commande laravel:
```console
laravel new monProjet --git
```

Vous devez ajouter avant votre premier commit le fichier .gitignore, ajoutez ce contenu généré par l'option --git
```console
/node_modules
/public/hot
/public/storage
/storage/*.key
/vendor
.env
.env.backup
.phpunit.result.cache
docker-compose.override.yml
Homestead.json
Homestead.yaml
npm-debug.log
yarn-error.log
/.idea
/.vscode
```

Vous constatez que le fichier .env fait partie du fichier .gitignore. Lorsque vous pousserez vos modifications, .env ne sera pas envoyé et sera gardé précieusement. ;)

Le plus simple est tout de même de créer votre projet avec l'option --git si vous utilisez la commande laravel.

## 4. Les migrations
Les migrations permettent de créer/modifier une base de données: tables, index, relation, etc. Toute modification est enregistrée. Il y a donc un suivi de tout ce que vous avez fait sur vos tables. On peut même faire marche arrière sur une migration (rollback). C'est un peu le git de votre base de données. Ici, nous allons voir rapidement les migrations mais la documentation Laravel complétera cette introduction: [Database: Migrations](https://laravel.com/docs/11.x/migrations)

Pour que nos accès à la base de données mysql fonctionnent, il faut que l'on active l'extension dans le fichier php.ini.
Lorsque vous lancerez vos migrations, si vous avez ce message d'erreur:PDOException::("could not find driver") vous devez activer l'extension pdo_mysql. Pour cela, ouvrez le fichier php.ini et enlevez le ; se trouvant en début de ligne de l'extension: extension=pdo_mysql

Dans tout nouveau projet Laravel, il y a des migrations qui sont déjà présentes.
Celles-ci se trouvent dans le répertoire database\migrations: 
- 0001_01_01_000000_create_users_table.php
- 0001_01_01_000001_create_cache_table.php
- 0001_01_01_000002_create_jobs_table.php

Regardons les tables qui ont été créées:
```console
mysql -u root -p
use cupcake;
show tables;
```
Résultat:
```console
+-----------------------+
| Tables_in_eloquent    |
+-----------------------+
| cache                 |
| cache_locks           |
| failed_jobs           |
| job_batches           |
| jobs                  |
| migrations            |
| password_reset_tokens |
| sessions              |
| users                 |
+-----------------------+
9 rows in set (0,000 sec)
```
Ces tables sont toutes vides sauf la table migrations. Regardons le contenu de celle-ci:
```console
mysql -u root -p
use cupcake;
select * from migrations;
```
Résultat:
```console
+----+--------------------------------------+-------+
| id | migration                            | batch |
+----+--------------------------------------+-------+
|  1 | 0001_01_01_000000_create_users_table |     1 |
|  2 | 0001_01_01_000001_create_cache_table |     1 |
|  3 | 0001_01_01_000002_create_jobs_table  |     1 |
+----+--------------------------------------+-------+
3 rows in set (0,000 sec)
```
On voit que ces enregistrements correspondent aux noms des fichiers contenus dans le répertoire database\migrations. 

### 4.1 Comparons table et migration
Prenons la table users et regardons la structure des champs:
```console
mysql -u root -p
use cupcake;
show fields from users;
exit;
```
Résultat:
```
+-------------------+-----------------+------+-----+---------+----------------+
| Field             | Type            | Null | Key | Default | Extra          |
+-------------------+-----------------+------+-----+---------+----------------+
| id                | bigint unsigned | NO   | PRI | NULL    | auto_increment |
| name              | varchar(255)    | NO   |     | NULL    |                |
| email             | varchar(255)    | NO   | UNI | NULL    |                |
| email_verified_at | timestamp       | YES  |     | NULL    |                |
| password          | varchar(255)    | NO   |     | NULL    |                |
| remember_token    | varchar(100)    | YES  |     | NULL    |                |
| created_at        | timestamp       | YES  |     | NULL    |                |
| updated_at        | timestamp       | YES  |     | NULL    |                |
+-------------------+-----------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)
```
Maintenant, regardons le fichier correspondant, c'est à dire 2014_10_12_000000_create_users_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });

        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });

        Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
        Schema::dropIfExists('password_reset_tokens');
        Schema::dropIfExists('sessions');
    }
};
```
Je vous laisse 5 minutes pour l'analyser et me dire ce que vous avez constaté.
- Que fait la fonction up() ?
- Que fait la fonction down() ?

### 4.2 Options de migration
Voici les options de migration:
- php artisan migrate   => Exécute toutes les migrations qui n'ont pas encore été exécutées du répertoire database\migrations
- php artisan migrate:rollback => Revient à l'état précédent l'actuelle migration.
- php artisan migrate:refresh => Fait un rollback de toutes les migrations via la méthode down() de chaque migration. Ensuite relance les migrations. ATTENTION A NE JAMAIS EXECUTER EN PRODUCTION !!!!
- php artisan migrate:fresh => Supprime toutes les tables et relance toutes les migrations. ATTENTION A NE JAMAIS EXECUTER EN PRODUCTION !!!!
- php artisan migrate:status => indique le status des migrations: exécutées ou non.

### 4.3 Valeur par défaut
Dans la fonction up() d'une migration on peut avoir des champs avec une valeur par défaut. Par exemple, une table employe avec un champ boolean 'renvoye' à false. En effet, normalement un nouvel employé ne peut être déjà renvoyé. :) Donc on peut mettre par défaut à false la valeur.

```php
    public function up()
    {
        Schema::create('employe', function (Blueprint $table) {
            $table->id();
            $table->string('nom');
            $table->string('email')->unique();
            $table->string('password');
            $table->boolean('renvoye')->default(false);
            $table->string('surnom')->nullable();
            $table->timestamps();
        });
    }
```

Lors du lance de la migration, la table employe sera créée avec les champs suivants:
- id (auto_increment) et primary key
- nom (varchar) obligatoire
- email (varchar) avec une contrainte d'unicité (unique) obligatoire
- password (varchar) obligatoire
- renvoye (boolean) avec une valeur par défaut à false.
- surnom (varchar) nullable
- created_at et updated_at (timestamp) obligatoire. Ces deux champs sont ajoutés automatiquement par Laravel.

## 5. Eloquent
Eloquent est l'ORM utilisé par Laravel:
> Un mapping objet-relationnel (en anglais object-relational mapping ou ORM) est un type de programme informatique qui se place en interface entre un programme applicatif et une base de données relationnelle pour simuler une base de données orientée objet. 
> 
> Ce programme définit des correspondances entre les schémas de la base de données et les classes du programme applicatif. On pourrait le désigner par là, « comme une couche d'abstraction entre le monde objet et monde relationnel ».
> 
> Du fait de sa fonction, on retrouve ce type de programme dans un grand nombre de frameworks sous la forme de composant ORM qui a été soit développé, soit intégré depuis une solution externe.

Source [Wikipedia](https://fr.wikipedia.org/wiki/Mapping_objet-relationnel).

### 5.1 Eloquent et le design pattern 'Active record'
Dans le design pattern [Active record](https://fr.wikipedia.org/wiki/Active_record) est utilisé pour faire correspondre une table à une classe. Les attributs de la table sont encapsulés dans une classe. De cette manière, un enregistrement d'une table correspond à un objet.

### 5.3 Tinker
Tinker veut dire littéralement "bidouilleur". Donc c'est un outil qui permet de bidouiller du code dans son contexte en ligne de commande. 
L'intérêt est de ne pas mettre du code de tests dans notre application.
C'est rapide et on ne perd pas trop de temps à tester via un navigateur.

### 5.3 Création d'un user via tinker
Tinker est très utile quand vous voulez interagir avec votre base de données très rapidement sans faire de programme. Et il est parfait pour vous présenter Eloquent et le design patter Active record.

Nous allons créer un premier user dans notre base de données avec tinker:
```console
php artisan tinker
```
Dans tinker, nous allons créer un utilisateur:
```php
//Nouvelle instance de User
$user = new App\Models\User;
//On remplit les attributs name, emai, password
$user->name='Piette';
$user->email='johnny.piette@gmail.com';
$user->password=bcrypt('!password');
```
On sauve notre objet dans la base de données :):
```php
//On sauve notre objet dans la base de données :)
$user->save();
//Affichons le contenu de notre objet après save()
$user;
```
Résultat de $user dans tinker:
```console
= App\Models\User {#5073
    name: "Piette",
    email: "johnny.piette@gmail.com",
    #password: "$2y$12$g5MntYKpxw0gASM1z6FW9eNPLpx7wJbDuhaUPMzhFRWTuKMxK.TRi",
    updated_at: "2024-05-08 06:05:34",
    created_at: "2024-05-08 06:05:34",
    id: 1,
  }
```
Ne fermez pas votre console tinker, nous allons avoir besoin plus loin de $user.

Vérifions que l'utilisateur a bien été créé et qu'il correspond à $user:
```console
mysql -u root -p
use cupcake;
select * from users;
exit;
```
Résultat:
```console
+----+--------+-------------------------+-------------------+--------------------------------------------------------------+----------------+---------------------+---------------------+
| id | name   | email                   | email_verified_at | password                                                     | remember_token | created_at          | updated_at          |
+----+--------+-------------------------+-------------------+--------------------------------------------------------------+----------------+---------------------+---------------------+
|  1 | Piette | johnny.piette@gmail.com | NULL              | $2y$12$g5MntYKpxw0gASM1z6FW9eNPLpx7wJbDuhaUPMzhFRWTuKMxK.TRi | NULL           | 2024-05-08 06:05:34 | 2024-05-08 06:05:34 |
+----+--------+-------------------------+-------------------+--------------------------------------------------------------+----------------+---------------------+---------------------+
1 row in set (0,000 sec)

```
Et oui, ça correspond ! :)

Notez au passage que l'on a utilisé bcrypt qui a crypté notre mot de passe car dans une DB, il ne faut jamais stocker un mot de passe en clair: just a reminder. ;) 

### 5.4 Mise à jour de User via tinker
Nous allons changer le nom de l'objet $user:
```console
-- On change la valeur de l'attribut 'name'
$user->name='Defalque';
$user->save();
$user;
```
Résultat:
```console
= App\Models\User {#5073
    name: "Honoré",
    email: "johnny.piette@gmail.com",
    #password: "$2y$12$g5MntYKpxw0gASM1z6FW9eNPLpx7wJbDuhaUPMzhFRWTuKMxK.TRi",
    updated_at: "2024-05-08 06:09:26",
    created_at: "2024-05-08 06:05:34",
    id: 1,
  }
```
Et oui, le nom a bien été changé dans la base de données en même temps que dans l'objet $user. C'est le design pattern Active record qui fait cela. :)

### 5.5 méthodes find, all 
Nous allons avant créer un nouveau User pour cette partie:
```console
use App\Models\User;
//Nouvelle instance de User
$user = new User;
//On remplit les attributs name, emai, password
$user->name='Piettus';
$user->email='djoni.piettus@gmail.com';
$user->password=bcrypt('!password');
//On sauve notre objet dans la base de données :)
$user->save();
```

J'ai ajouté un use pour ne pas avoir à écrire App\Models\User à chaque fois.

On va rechercher l'utilisateur avec l'id = 1 et ensuite id=2. Enfin, on affichera tous les utilisateurs.

- Utlisateur avec l'id = 1 et ensuite l'id = 2
    ```console
    $user1 = User::find(1); //On recherche l'utilisateur avec l'id = 1
    $user2 = User::find(2); //On recherche l'utilisateur avec l'id = 2
    ```
- Afficher tous les Users
    ```console
    User::all();
    ```
    Résultat de tous les Users:
    ```console
    => Illuminate\Database\Eloquent\Collection {#4446
    all: [
      App\Models\User {#5144
        id: 1,
        name: "Honoré",
        email: "johnny.piette@gmail.com",
        email_verified_at: null,
        #password: "$2y$12$g5MntYKpxw0gASM1z6FW9eNPLpx7wJbDuhaUPMzhFRWTuKMxK.TRi",
        #remember_token: null,
        created_at: "2024-05-08 06:05:34",
        updated_at: "2024-05-08 06:09:26",
      },
      App\Models\User {#6156
        id: 2,
        name: "Piettus",
        email: "djoni.piettus@gmail.com",
        email_verified_at: null,
        #password: "$2y$12$OFf.FGQ5DfteVgYXXLgTGOZdUKIZwONbmfld6V0icBBVx4NpFag52",
        #remember_token: null,
        created_at: "2024-05-08 06:10:52",
        updated_at: "2024-05-08 06:10:52",
      },
    ],
  }
    ```
J'ai affiché le résultat de tous les Users car il est intéressant de remarquer qu'Eloquent nous indique que ce qui est retourné est une Collection: un tableau.

C'est beau non ? :)

### 5.6 pluck méthode
Maintenant, j'ai envie de connaître tous les noms d'utilisateurs et rien d'autre.
```console
User::pluck('name');
```
Résultat:
```console
=> Illuminate\Support\Collection {#4391
     all: [
       "Piette Jacques",
       "Piettus",
     ],
   }
```
A nouveau une collection où l'on voit tous les noms.
Pour afficher le premier résultat de pluck, je peux le faire de deux manières:
```console
    -- Première manière
    User::pluck('name')[0];
    -- Seconde manière
    User::pluck('name')->first();
```
### 5.7 Mettre à jour un enregistrement
La mise à jour peut se faire de deux manières soit via la méthode update() ou la méthode save().

#### 5.7.1 via la méthode save()
Le principe est simple, on récupère l'enregistrement et on met à jour les attributs qui doivent être changés.
Ensuite, on utilise la méthode save() et c'est mis à jour.
```php
use App\Models\User;
$utilisateur = User::find(1); //On recherhe l'utilisateur avec l'id = 1
$utilisateur->name='Pietta';
$utilisateur->email='johnny.pietta@gmail.com';
$utilisateur->save();
```
#### 5.7.2 via la méthode update()
On récupère aussi l'enregistrement et dans la méthode update on donne un tableau associatif où l'on affectera les attributs de la classe.
```php
App\Models\User::find(1)->update(['name'=>'Pietta','email'=>'johnny.pietta@gmail.com']);
```

### 5.8 Les conditions
Si on veut utiliser la clause where SQL, on peut le faire via la méthode where() que l'on va illustrer par différents exemples. La syntaxe pourra vous sembler étrange mais on s'y fait assez vite. Vous aurez plus d'infos dans la [documentation Laravel](https://laravel.com/docs/11.x/queries#basic-where-clauses).

Pour les prochains exemples on va réinitialier la base de données:
```console
php artisan migrate:fresh
```
via tinker, nous allons ajouter 5 enregistrements grâce à la méthode insert de la classe User:
```console
php artisan tinker
```
Dans Tinker:
```php
use App\Models\User;
    User::insert([
        [
            'name' => 'Piette',
            'email' => 'algorithm@gmail.com',
            'password' => bcrypt('L353nf4nt5')
        ],
        [
            'name' => 'Jacques',
            'email' => 'jacques.veronique@tutu.be',
            'password' => bcrypt('p@ssw0rd')
        ],      
        [
            'name' => 'Jacques',
            'email' => 'jacques.andre@piette.be',
            'password' => bcrypt('p@ssw0rd')
        ],
        [
            'name' => 'Perezzz',
            'email' => 'perezzz.alvaro@bank.com',
            'password' => bcrypt('myc4s4')
        ],
        [
            'name' => 'jemina',
            'email' => 'trum.jemina@home.br',
            'password' => bcrypt('t01lets')
        ]
    ]);
```

On a ajouté 5 utilisateurs grâce à la méthode insert de la classe User. Nous avons fourni un tableau associatif pour chaque utilisateur avec les attributs name, email et password.

On va maintenant les afficher:
```php
User::all();
```

#### 5.8.1 Opérateurs de comparaison 
En Laravel, pour effectuer des requêtes, on va voir comment utiliser les opérateurs SQL suivants:
- \> et \<
- \>= et \<=
- = et \<\>
- like
- and
- or
- between et not between
- in et notIn
- null et not null

Afficher les utilisateurs dont le mail est `algorithm@gmail.com`. Dans l'exemple j'affecte le résultat de la méthode get() dans la variable $user;
```php
$user = User::where('email','algorithm@gmail.com')->get();
```
Ou bien mais plus long:
```php
$user = User::where('email','=','algorithm@gmail.com')->get();
```
Par défaut, l'opérateur est = si on ne le précise pas.

Afficher les utilisateurs dont l'id > 1
```php
User::where('id','>',1)->get();
```

Afficher les utilisateurs dont l'id >= 2
```php
User::where('id','>=',2)->get();
```

Afficher les utilisateurs dont l'id <= 4
```php
User::where('id','<=',4)->get();
```

Afficher les utilisateurs dont le nom n'est pas 'Pietta' et que le mail contient 'gmail.com'. On chaîne les where tout simplement. :)
```php
User::where('name','<>','Piette')->where('email','like','%gmail.com')->get();
```

Afficher les utilisateurs dont le nom est 'Pietta' ou 'Jacques'. Pour le 'or' on va chaîner avec un orWhere:
```php
User::where('name','Piette')->orWhere('name','Jacques')->get();
```

Afficher les utilisateurs dont l'id est compris entre 2 et 4:
```php
User::whereBetween('id',[2,4])->get();
```

Afficher les utilisateurs dont l'id n'est pas compris entre 2 et 4:
```php
User::whereNotBetween('id',[2,4])->get();
```

Afficher les utilisateurs dont l'id a une des valeurs suivantes:1,3 ou 5
```php
User::whereIn('id',[1,3,5])->get();
```

Afficher les utilisateurs dont l'id n'a pas une des valeurs suivantes:1,3 ou 5
```php
User::whereNotIn('id',[1,3,5])->get();
```
## 5b. Les fonctions query() et get()

### 5b.1 La fonction query()
La fonction query() permet de construire une requête SQL. Elle retourne un objet Query Builder. C'est un objet qui permet de construire une requête SQL. On peut lui ajouter des conditions, des clauses, des groupements, des tris, etc.

### 5b.2 La fonction get()
La fonction get() permet de récupérer les résultats de la requête. Elle retourne une collection d'objets Eloquent. Si aucun résultat n'est trouvé, une collection vide sera retournée.

Tant que vous n'avez pas appelé la fonction get(), vous pouvez continuer à ajouter des conditions à votre requête. Rien ne sera exécuté tant que vous n'avez pas appelé la fonction get().

En C# (lire Csharp), on fait pareil non pas avec Eloquent mais avec Entity Framework qui est aussi un ORM. On construit une requête et on l'exécute avec la méthode ToList(). Ici, dans Laravel, on l'exécute avec get().

### 5b.3 Exemple
query() et get() sont très utiles pour construire des requêtes complexes. On peut les chaîner pour ajouter des conditions, des clauses, des groupements, des tris, etc comme dans une page de recherche d'un site par exemple.

Exemple:
```php
// Validation des entrées
$request->validate([
    'name' => 'string|max:255|nullable',
    'partial_email' => 'string|max:255|nullable',
    'age' => 'integer|nullable'
]);

$name = $request->input('name');
$partial_email = $request->input('partial_email');
$age = $request->input('age');
$users = User::query();
if($name){
    $users = $users->where('name',$name);
}
if($partial_email){
    $users = $users->where('email','like',"%$partial_email");
}
if($age){
    $users = $users->where('age',$age);
}
$users= $users->get();
```
Valide les entrées:
- name: une chaîne de caractères de 255 caractères maximum ou null.
- partial_email: une chaîne de caractères qui doit avoir 255 caractères maximum ou null.
- age: un entier ou null.

Si une des règles n'est pas respectée, la page du formulaire sera affichée avec les erreurs: si vous avez géré les erreurs dans votre vue.

Ensuite, on va chercher les utilisateurs dont le nom est $name, dont l'email contient $partial_email et dont l'âge est $age.

On peut aussi ajouter des clauses, des groupements, des tris, etc. C'est très puissant et très pratique.

## 5c. La méthode when()

Dans l'exemple précédent, on a utilisé des if pour ajouter des conditions à notre requête. On peut aussi utiliser la méthode when() qui est très pratique pour ajouter des conditions à une requête. La méthode when() va tester si un des paramètres est vrai et si c'est le cas, elle va ajouter une condition à la requête via une fonction anonyme.

Modifions notre code qui traite des conditions pour utiliser la méthode when():
```php
$users = User::query()
    ->when($name, function($query) use ($name){
        return $query->where('name',$name);
    })
    ->when($partial_email, function($query) use ($partial_email){
        return $query->where('email','like',"%$partial_email");
    })
    ->when($age, function($query) use ($age){
        return $query->where('age',$age);
    })
    ->get();
```

On a remplacé les if par des when(). C'est plus court et plus lisible. :) Mais c'est une question de goût.

Pour rappel, la méthode use() permet d'utiliser des variables extérieures dans une fonction anonyme car elles ne sont pas accessibles directement car elles sont dans une portée différente.

## 6. Création de la table Cupcake
```console
php artisan make:migration create_cupcakes_table
```
Le fichier de migration a été créé dans le répertoire database\migrations
Ouvrez ce fichier et modifiez-le de la sorte:
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateCupcakesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('cupcakes', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('description');
            $table->string('imageName');
            $table->decimal('price');
            $table->integer('stock');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('cupcakes');
    }
}
```
Laravel a compris grâce au verbe create qu'il doit créer une table cupcakes et a ajouté tout seul le nom de la table. De base, il ajoute un id et un timestamps.

Lançons notre migration:
```console
php artisan migrate
```
La table cupcakes a été créée avec les champs correspondants à ceux que nous avons définis.

## 7. Création du modèle Cupcake
Nous avons créé notre table cupcakes. Maintenant, nous allons créer la classe Cupcake qui permettra d'appliquer le design pattern Active record.
```console
php artisan make:model Cupcake
```
La classe Cupcake a été créée dans le répertoire App\Models

On peut aussi créer un modèle et une migration en même temps:
```console
php artisan make:model Tutu -m
```
## 8. Ajout d'un cupcake via Tinker

Pour rappel, j'utilise Tinker dans ce cours pour que vous puissiez voir rapidement le résultat de vos actions. Mais en production, vous n'utiliserez pas Tinker. Vous aurez un formulaire qui vous permettra d'ajouter un cupcake. Ce code sera dans un contrôleur par exemple. Tinker me permet lors de ce cours de vous montrer rapidement le résultat de mes actions sans devoir créer un contrôleur, une vue, etc.

```console
php artisan tinker
```
Et dans tinker:
```php
use App\Models\Cupcake;
$cupcake = new Cupcake;
$cupcake->name = 'Le Pinky';
$cupcake->description = 'Bla bla bla bla...';
$cupcake->imageName = 'cupcake1.jpg'; 
$cupcake->stock = 10;
$cupcake->price = 2.5;
$cupcake->save();
```
Et voilà ! Notre object $cupcake est devenu __persistant__ dans le base de données. D'un objet, il est devenu un enregistrement dans la table cupcakes.

Si vous allez souvent utiliser Cupcake, par facilité dès le départ faites un use App\Models\Cupcake; dans tinker.

Si notre programme se termine, l'objet disparait de la mémoire mais l'enregistrement, lui restera/persistera dans la base de données grâce à Eloquent et le design pattern Active record via la méthode save().

## 9. Stocker un Mot de passe en DB
Ceci est un point ajouté à la demande d'un étudiant:"Monsieur comment faire la gestion des mots de passe en Laravel ?"

Premièrement, il ne faut pas stocker votre mot de passe en clair dans une base de données. Je l'ai fait il y a très très longtemps par le passé mais c'était très mauvais, je dois le reconnaître. ;) De nos jours, il serait suicidaire de le faire...

Pour résumer très rapidement, de votre mot de passe on fait des calculs et on obtient un résultat. Mais on ne peut pas faire l'opération inverse pour retrouver le mot de passe.

Pour stocker votre mot de passe, utilisez simplement la commande password_hash de php. Pour Laravel, utilisez soit le helper bcrypt ou bien fonction statique make de la classe Hash.

Avec password_hash en php
```php
$password = password_hash('votremotdepasse',PASSWORD_DEFAULT);
```
- PASSWORD_DEFAULT (='2y'): utilise l'algorithme bcrypt par défaut. Pourrait peut-être changé dans le futur si un algo plus robuste est implémenté par défaut.
- PASSWORD_BCRYPT (='2y'): utilise l'algorithme bcrypt.
- PASSWORD_ARGON2I (='argon2i'): utilise l'algorithme argon2i.
- PASSWORD_ARGON2ID (='argon2id'): utilise l'algorithme argon2id.

password_algos() vous retournera les différents algorithmes de cryptages que vous pouvez utilisez pour vos mots de passe.

Le hashage de votre mot de passe pourrait être: \$2y$10$MV6iXclPOt0R6vFh0xPoq.xQGLl0A7upIXXMdaYc1.7MCT7K48era
Mais si vous utilisez bcrypt avec le même mot de passe, le résultat de \$password changera. Donc il ne faut pas croire qu'à un mot de passe crypté sera toujours le même.

Donc à un mot de passe peut correspondre plusieurs hashs.
Mais à un hash devrait correspondre un seul mot de passe. Sauf en cas de collision. C'était le cas de certains algorithmes de hashages qui avaient ce type de bug: sha1, md5. Linkedin en 2012 stockait ses mots de passe avec du sha1 et il a fallu 3 jours pour récupérer 90% des mots de passe. :) 

Avec Hash::make de Laravel
```php
use Illuminate\Support\Facades\Hash;
$password = Hash::make('votremotdepasse');
```

Avec le helper bcrypt de Laravel
```php
use Illuminate\Support\Facades\Hash;
$password = bcrypt('votremotdepasse');
```
Pour Hash::make, par défaut, Laravel va utiliser comme driver de hashage 'bcrypt'. On pourrait aussi utiliser argon et argon2id.

En regardant les sources de Laravel, j'ai vu que c'était indiqué dans le fichier: config\hashing.php.

## 10. Vérifier un Mot de passe
Pour le mot de passe, on ne décrypte pas un mot de passe avec une fonction.

Donc si vous avez perdu le mot de passe, l'administrateur ne pourra pas vous le fournir s'il a été crypté. Il devra vous en faire un nouveau qui sera lui aussi crypté. Ou bien, vous recevrez par email un lien vers un formulaire où vous pourrez mettre un nouveau mot de passe. Ca dépend du contexte...

On a en php la fonction password_verify et en Laravel la fonction Hash::check

Avec password_verify en php
```php
$password = 'votremotdepasse';
if(password_verify($password,'$2y$10$MV6iXclPOt0R6vFh0xPoq.xQGLl0A7upIXXMdaYc1.7MCT7K48era')){
    echo "Le mot de passe est correct";
} else {
    echo "Le mot de passe n'est pas correct !";
}
```

Avec Hash::check en Laravel
```php
use Illuminate\Support\Facades\Hash;
$password = 'votremotdepasse';
if(Hash::check($password,'$2y$10$MV6iXclPOt0R6vFh0xPoq.xQGLl0A7upIXXMdaYc1.7MCT7K48era')){
    echo "Le mot de passe est correct";
} else {
    echo "Le mot de passe n'est pas correct !";
}
```

## 11. Ajouter une colonne
On va ajouter une colonne 'arrete' pour indiquer qu'un produit n'est plus produit.

On crée la migration:
```console
php artisan make:migration add_arrete_to_cupcakes --table=cupcakes
``` 

On modfie la migration
```php
    public function up()
    {
        Schema::table('cupcakes', function (Blueprint $table) {
            $table->boolean('arrete')->default(false);
        });
    }

    public function down()
    {
        if (Schema::hasColumn('cupcakes', 'arrete')) {
            Schema::table('cupcakes', function (Blueprint $table) {
                $table->dropColumn('arrete');
            });
        }
    }
```
L'option --table=cupcakes indique que l'on va utiliser la table cupcakes mais le fait que dans le nom de la migration on ait ajouté 'to_cupcakes' indique aussi que l'on va utiliser la table cupcakes.

Quoiqu'il en soit, vérifiez que la classe Schema appelle la méthode statique table() et non create().

Cette méthode static table() permet de modifier une table existante. La méthode create() permet de créer une table.

On exécute la migration:
```
php artisan migrate
```
Résultat:
```console
INFO  Running migrations.  

2024_05_08_063246_add_arrete_to_cupcakes ............................................................................................... 61.83ms DONE
```


## 12. Mettre à jour une colonne
Pour modifier une colonne, il faut créer une nouvelle migration. On ne modifie pas une migration existante. On pourrait le faire mais c'est une mauvaise pratique. On ne modifie pas une migration déjà exécutée. On crée une nouvelle migration.

Création de la migration
```console
php artisan make:migration update_stock_to_cupcakes 
```

Modification de la migration
```php

    public function up()
    {
        Schema::table('cupcakes', function (Blueprint $table) {
            $table->integer('stock')->default(0)->change();
        });
    }

    public function down()
    {
        if (Schema::hasColumn('cupcakes', 'stock')) {
            Schema::table('cupcakes', function (Blueprint $table) {
                $table->integer('stock')->default(NULL)->change();
            });
        }
    }
```

Exécution de la migration
```console
php artisan migrate
```
Et voilà, notre champ stock a été modifié. Il est passé de nullable à non nullable. Il a une valeur par défaut de 0.
<!--
Et bardaf c'est l'embardée, on reçoit le message d'erreur suivant:'Changing columns for table "%s" requires Doctrine DBAL. Please install the doctrine/dbal package.'

Le message est on ne peut plus clair: on doit installer le package doctrine/dbal si on veut modifier une colonne.

Installation de la dépendance via composer
```console
composer require doctrine/dbal
```

Maintenant votre migration devrait fonctionner.
-->
## 13. Supprimer une colonne
Pour l'exercice, on a va ajouter une colonne inutile: le prix TVA comprise. En effet, on ne met pas de colonne qui pourrait être calculée en DB. C'est une perte inutile en base de données. Si vous 1 milliard d'enregistrements, vous avez 1 milliard de colonnes inutiles...

On va faire la migration
```console
php artisan make:migration add_pricevat_to_cupcakes --table=cupcakes
```

Modification de la migration:
```php
    public function up()
    {
        Schema::table('cupcakes', function (Blueprint $table) {
            $table->decimal('pricevat');
        });
    }

    public function down()
    {
        if (Schema::hasColumn('cupcakes', 'pricevat')) {
            Schema::table('cupcakes', function (Blueprint $table) {
                $table->dropColumn('pricevat');
            });
        }
    }
```

On exécute la migration
```console
php artisan migrate
```

Puis, votre chef vous dit que c'est une erreur de mettre une colonne où l'on pourrait calculer le prix TVA comprise. C'est inutile. On va la supprimer.

Deux manières:
- On fait une nouvelle migration avec le dropColumn dans la méthode up() et ajouter une colonne dans la méthode down();
- On fait un rollback et comme nous appelons la méthode dropColumn dans la méthode down() de la précédente migration, la colonne sera supprimée. Ensuite on supprime le fichier de migration. (A voir si c'est une bonne méthode)...

Créons la migration
```console
php artisan make:migration drop_pricevat_to_cupcakes --table=cupcakes
```

Modifions la migration
```php
    public function up()
    {
        Schema::table('cupcakes', function (Blueprint $table) {
            $table->dropColumn('pricevat');
        });
    }

    public function down()
    {
        if (Schema::hasColumn('cupcakes', 'pricevat')) {
            Schema::table('cupcakes', function (Blueprint $table) {
                $table->decimal('pricevat');
            });
        }
    }
```

On exécute la migration
```console
php artisan migrate
```

## 14. Les relations
Dans une base de données, il y a des tables. Et il existe aussi des liens entre ces tables qu'on appelle relations. Relation de 1 à plusieurs (One to many), de plusieurs à plusieurs (many to many).

Nous allons voir comme imprémenter ces relations en Laravel.

Avant d'aller plus loin, nous allons créer le modèle Categorie et la migration qui va créer la table categories en une seule commande. Nnous l'avons déjà fait précédemment.

```console
php artisan make:model Category -m
```

Il est intéressant de noter que la classe Category est au singulier et que Laravel a mis au pluriel Category quand il a créé la migration: create_categories_table.php et lors de l'appel de la fonction statique create.

Modifions cette migration avec:
```php
class CreateCategoriesTable extends Migration
{
    public function up()
    {
        Schema::create('categories', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->timestamps();
        });
    }

    public function down()
    {
        Schema::dropIfExists('categories');
    }
}
```
Exécutons la migration:
```php
php artisan migrate
```

### 14.1 One to many
Nous prendrons le cas de notre table cupcakes. A un cupcake va correspondre une catégorie. Et une catégorie correspond à un ou plusieurs cupcakes (voire aucun).

Nous pourrons par exemple voir directement d'une categorie quels sont les cupcakes liés:
```php
//On prend par exemple la première catégorie de la table Categories
$cat = Category::first();
$cupcakes = $cat->cupcakes;
//Ou en une ligne
$cupcakes = Category::first()->cupcakes;
```
Ou à l'inverse voir à quelle catégorie appartient un cupcake:
```php
$cat = Cupcake::first()->category;
```

Mais nous allons construire la mécanique avant d'arriver à cela...


Créons donc un lien entre la table cupcakes et la table categories:
```console
php artisan make:migration add_categoryid_to_cupcakes
```

Modifions cette migration pour ajouter la clef étrangère:
```php
class AddCategoryidToCupcakes extends Migration
{
    public function up()
    {
        Schema::table('cupcakes', function (Blueprint $table) {
            $table->foreignId('category_id')->nullable();
        });
    }

    public function down()
    {
        if (Schema::hasColumn('cupcakes', 'category_id')) {
            Schema::table('cupcakes', function (Blueprint $table) {
                $table->dropColumn('category_id');
            });
        }
    }
}
```

On va exécuter la migration:
```console
php artisan migrate
```

Maintenant, il faut que nous ajoutions une fonction dans la classe Category et une fonction dans la classe Cupcake.

Nous devons définir le fait qu'un Cupcake a une Categorie (belongsTo). Et qu'une Categorie a un ou plusieurs Cupcakes (HasMany).

La classe Cupcake:
```php
class Cupcake extends Model
{
    use HasFactory;

    public function category(){
        return $this->belongsTo(Category::class);
    }

}
```

La classe Category:
```php
class Category extends Model
{
    use HasFactory;


    public function cupcakes(){
        return $this->hasMany(Cupcake::class);
    }
}
```

Créons des catégories et des cupcakes via tinker
```php
use App\Models\Category;
use App\Models\Cupcake;

Category::insert([
    [
        'name' => 'Moelleux'
    ],
    [
        'name' => 'Croquant'
    ],      
    [
        'name' => 'Glacé'

    ]
]);

Cupcake::insert([
    [
        'name' => 'Le Pinky',
        'description' => 'Le pinky ce cupcake rose et délicieux !',
        'imageName' => 'pinky.png',
        'price' => 2.5,
        'stock' => 50,
        'category_id' => 1
    ],
    [
        'name' => 'Le Brown',
        'description' => 'Sa couleur brune vient d\'un chocolat du Brésil où les grains ont doré sous un soleil généreux.',
        'imageName' => 'brown.png',
        'price' => 3,
        'stock' => 175,        
        'category_id' => 2
    ],      
    [
        'name' => 'Le Caramel',
        'description' => 'Fait à partir de Caramel beurre salé fait maison, ravira les papilles gustatives des fins gourmets.',
        'imageName' => 'caramel.png',
        'price' => 2.75,
        'stock' => 99,        
        'category_id' => 3
    ],
    [
        'name' => 'Le Blue',
        'description' => 'Le pink ce cupcake rose et délicieux !',
        'imageName' => 'blue.png',
        'price' => 2.5,
        'stock' => 12,        
        'category_id' => 2
    ],
    [
        'name' => 'Le Rainbow',
        'description' => 'Une explosion de goûts et de couleur viendont titiller vos sens de la vue et du goût.',
        'imageName' => 'rainbow.png',
        'price' => 2,
        'stock' => 33,        
        'category_id' => Category::where('name','Croquant')->first()->id
    ]
]);
```
Regardez le dernier cupcake ajouté dans la méthode statique insert de la classe Cupcake.
Maintenant, amusons-nous un peu :)

J'ai envie de savoir quels Cupcakes font partie de la catégorie 'Croquant'
```php
Category::find(2)->cupcakes;
```
Laravel a fait pour vous une requête qui devrait ressembler à ceci:
```sql
SELECT cupcakes.*
FROM cupcakes
INNER JOIN categories ON cupcakes.category_id = categories.id
WHERE categories.id = 2;
```

J'ai envie de savoir le nom de la Catégorie du capcake dont l'id = 3
```php
Cupcake::find(3)->category->name
```
Laravel a fait pour vous une requête qui devrait ressembler à ceci:
```sql
SELECT categories.name
FROM categories 
INNER JOIN cupcakes ON categories.id = cupcakes.category_id
WHERE cupcakes.id = 3;
```

Il y a juste une chose à savoir c'est que la méthode category de la classe Cupcake est appelée comme un attribut sans les ().
Idem pour la méthode cupcakes de la classe Category qui est appelée sans les ().

J'espère que vous avez vu la facilité avec laquelle nous avons pu faire nos relation 'One to Many' avec Laravel :)

### 14.2 Many to many

Nous allons prendre un exemple simple: un cupcake peut être vendu dans un ou plusieurs magasins et un magasin peut vendre un ou plusieurs cupcakes.


Oui, votre exemple où un cupcake peut être vendu dans un ou plusieurs magasins et un magasin peut vendre un ou plusieurs cupcakes est parfait pour illustrer une relation many-to-many dans Laravel. Cela impliquera une table intermédiaire (souvent appelée table pivot) pour gérer les relations entre les cupcakes et les magasins. Voici comment vous pourriez configurer cela avec des migrations et des modèles :

### Étape 1 : Création des Migrations

Vous aurez besoin de trois migrations : une pour `cupcakes`, une pour `stores`, et une pour la table pivot `cupcake_store`.

**Migration pour `cupcakes`** :

```bash
php artisan make:migration create_cupcakes_table --create=cupcakes
```

**Contenu de la migration `create_cupcakes_table`** :

```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateCupcakesTable extends Migration
{
    public function up()
    {
        Schema::create('cupcakes', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->timestamps();
        });
    }

    public function down()
    {
        Schema::dropIfExists('cupcakes');
    }
}
```

**Migration pour `stores`** :

```bash
php artisan make:migration create_stores_table
```

**Contenu de la migration `create_stores_table`** :

```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database.Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateStoresTable extends Migration
{
    public function up()
    {
        Schema::create('stores', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('location');
            $table->timestamps();
        });
    }

    public function down()
    {
        Schema::dropIfExists('stores');
    }
}
```

**Migration pour la table pivot `cupcake_store`** :

```bash
php artisan make:migration create_cupcake_store_table 
```

**Contenu de la migration `create_cupcake_store_table`** :

```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateCupcakeStoreTable extends Migration
{
    public function up()
    {
        Schema::create('cupcake_store', function (Blueprint $table) {
            $table->foreignId('cupcake_id')->constrained()->onDelete('cascade');
            $table->foreignId('store_id')->constrained()->onDelete('cascade');
            $table->primary(['cupcake_id', 'store_id']); // Composite primary key
        });
    }

    public function down()
    {
        Schema::dropIfExists('cupcake_store');
    }
}
```

### Étape 2 : Création des Modèles

**Modèle `Cupcake`** :

```php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Cupcake extends Model
{
    public function stores()
    {
        return $this->belongsToMany(Store::class);
    }
}
```

**Modèle `Store`** :

```php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Store extends Model
{
    public function cupcakes()
    {
        return $this->belongsToMany(Cupcake::class);
    }
}
```

### Étape 3 : Utilisation des Relations

Vous pouvez ajouter des relations entre les cupcakes et les magasins et les récupérer comme suit :

- **Ajouter un Cupcake à un Magasin** :

```php
$store = Store::find(1);
$store->cupcakes()->attach($cupcakeId); // $cupcakeId est l'ID du cupcake que vous souhaitez ajouter
```

- **Récupérer tous les Cupcakes d'un Magasin** :

```php
$store = Store::find(1);
foreach ($store->cupcakes as $cupcake) {
    echo $cupcake->name;
}
```

- **Récupérer tous les Magasins où un Cupcake est disponible** :

```php
$cupcake = Cupcake::find(1);
foreach ($cupcake->stores as $store) {
    echo $store->name;
}
```

### Conclusion

Cet exemple montre comment configurer et utiliser des relations many-to-many dans Laravel. Les modèles et migrations sont structurés pour gérer efficacement ces types de relations, facilitant la gestion des données interconnectées dans votre application.




[:arrow_left:Revenir à la théorie.](../Theo/README.md)

---
_[Eqla](http://www.eqla.be) 2024 - Formation Laravel_





